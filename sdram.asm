MAIN: LUI X1, 917504 #LOAD UPPER IMM WITH E0000
ORI X1, X1, 14 #LOAD LOWER 12-BIT WITH 00E, AS A RESULT X1=E000000E, REFERRING TO LCD CURRENT STATE REGISTER
LUI X2, 917520 #LOAD UPPER IMM WITH E0010
ORI X2, X2, 0 #LOAD LOWER 12-BIT WITH 000, AS A RESULT X2=E0010000, REFERRING TO LED DIODE CONTROL REGISTER. NOTE: THE ONLY LED ON FPGA2.PCB IS AT THE LSB
ADDI X3, X0, 5 #AFTER AUTOMATIC INITIATION, THE LCD MODULE SHOULD BE IN STATE 5 (101)
CHECKLCD: LW X4, 0(X1)
BNE X4, X3, CHECKLCD #WAIT UNTIL LCD IS DONE WITH INTIALIZATION
SW X4, 0(X2) # TURN ON LED SINCE X4=5 AND ITS LOWEST BIT IS 1
# HERE: JAL X3, HERE

## PRINT INITIALIZATION
PRINT: ADDI X1, X0, 1 # USE X0 TO WRITE A LOW LEVEL 0, AND X1 TO WRITE A HIGH LEVEL 1
# SET LCD WRITE MODE
LUI X2, 917504
ORI X2, X2, 10 #LOAD X2 = E000000A TO ADDRESS LCD_READ_ENABLE SIGNAL
SH X0, 0(X2) #LCD_READ_ENABLE = 0, I.E. SET LCD IN WRITE MODE SO THAT IT WILL ONLY RECEIVE COMMANDS FROM CPU
# LOWER LCD_CS TO SELECT THE LCD
LUI X2, 917504
ORI X2, X2, 0
SH X0, 0(X2) #LCD_CS = 0

## DELAY FOR 1S
JAL X9, DELAY1S

## DISPLAY "RISC-V RV32I"
ADDI X10, X0, 32
ADDI X11, X0, 48
ADDI X12, X0, 82
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 60
ADDI X12, X0, 73
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 72
ADDI X12, X0, 83
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 84
ADDI X12, X0, 67
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 96
ADDI X12, X0, 45
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 108
ADDI X12, X0, 86
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 120
ADDI X12, X0, 32
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 132
ADDI X12, X0, 82
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 144
ADDI X12, X0, 86
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 156
ADDI X12, X0, 51
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 168
ADDI X12, X0, 50
JAL X9, DISP
ADDI X10, X0, 32
ADDI X11, X0, 180
ADDI X12, X0, 73
JAL X9, DISP

## DELAY FOR 1S
JAL X9, DELAY1S


##########################################################
## read and write operations on DRAM
##########################################################

LUI X8, 16 # write 16*4096 = 65536 times, covering 2^7 rows, 512 times per row
ORI X8, X8, 0 # loop bound
ADDI X5, X0, 0 # loop variable
LUI X2, 917536  # E0020 loaded into the upper 20 bits of X2
ORI X2, X2, 0

WRITELOOP1: LW X3, 16(X2) # read the MMU's internal refresh timer. Avoid getting too close to the refresh window
LUI X4, 756
BGE X3, X4, WRITELOOP1 # wait until the timer resets
BEQ X5, X8, REST1
ADDI X3, X5, 0
SW X3, 4(X2) # always set write address first
SUB X3, X0, X5
SUB X3, X3, X1 
SW X3, 0(X2) # once write data is set, MMU will be triggered to service this write request
#just delay a little while, say 15 cycles
ADDI X3, X0, 5
WLOOP: BEQ X3, X0, LVUPDATE
ADDI X3, X3, -1
JAL X0, WLOOP
LVUPDATE: ADDI X5, X5, 1
JAL X0, WRITELOOP1

# a long delay to give the DRAM time to possibly lose data
REST1: ADDI X3, X0, 360
DELAY1HR: BEQ X3, X0, WRITEFINISH 
JAL X9, DELAY10S
ADDI X3, X3, -1
JAL X0, DELAY1HR


#now read it back
WRITEFINISH: ADDI X5, X0, 0
ADDI X8, X0, 128
READLOOP1: LUI X2, 917536  # E0020 loaded into the upper 20 bits of X2
ORI X2, X2, 0 
LW X3, 16(X2) # read the MMU's internal refresh timer. Avoid getting too close to the refresh window
LUI X4, 756
BGE X3, X4, READLOOP1
BEQ X5, X8, READFINISH  
LUI X2, 917536  # E0020 loaded into the upper 20 bits of X2
ORI X2, X2, 0
#ADDI X3, X0, 6 # prepare the read address, try to read the RAM unit just written to
SLLI X3, X5, 9
SW X3, 8(X2) # directly set the read address to trigger a read service by the MMU
#also delay a little while
ADDI X3, X0, 5
WLOOP1: BEQ X3, X0, DONE1
ADDI X3, X3, -1
JAL X0, WLOOP1
#now check if read request has been serviced
DONE1: LW X20, 8(X2) # read after the MMU moves data from DRAM into its internal buffer
ADDI X21, X0, 304
ADDI X22, X0, 0
JAL X9, DISPREG

LUI X2, 917536
ORI X2, X2, 0
LW X20, 20(X2)
ADDI X21, X0, 288
ADDI X22, X0, 0
JAL X9, DISPREG

JAL X9, DELAY1S

ADDI X5, X5, 1
JAL X0, READLOOP1

READFINISH: JAL X0, WRITEFINISH
## PROGRAM FINISH
LUI X2, 917504
ORI X2, X2, 0
SH X1, 0(X2) #DE-SELECT THE LCD MODULE
FINISH: JAL X9, FINISH

################ procedure to display a 32-bit register ##############
#### X20 stores the 32-bit to be displayed
#### X21 specifies the row to display (0-304, step size 16)
#### X22 specifies the column position of the first character (0-224, step size 12)
DISPREG: ADDI X19, X9, 0 #back up return address
ADDI X23, X0, 8 #loop variable
CLOOP: BEQ X23, X0, DONE
ADDI X24, X0, 15
ADDI X25, X23, -1
SLLI X25, X25, 2
SLL X24, X24, X25
AND X24, X24, X20
SRL X25, X24, X25
ADDI X10, X21, 0 #set row position
ADDI X11, X22, 0 #set column position
ADDI X24, X0, 10 #test if greater than 10. If so, display as A, B, C, D, E, F. Otherwise, as 0~9
SLT X24, X25, X24
BEQ X24, X0, DISPL
ADDI X12, X25, 48
JAL X9, DISP
ADDI X23, X23, -1
ADDI X22, X22, 12
JAL X0, CLOOP
DISPL: ADDI X12, X25, 55 # if the hex digit is 10, then 10+55=65 to display an A
JAL X9, DISP
ADDI X23, X23, -1
ADDI X22, X22, 12
JAL X0, CLOOP
DONE: ADDI X9, X19, 0
JALR X0, 0(X9)

################ PROCEDURE TO DISPLAY AN ASCII CHARACTER ###############
#### X10 STORES THE STARTING ROW PIXEL COUNT AND X11 STORES THE STARTING COLUMN PIXEL COUNT
#### THE STARTING POSITION IS THE UPPERLEFT CORNER OF THE CHARACTER
#### X12 STORES THE ASCII VALUE OF THE CHARACTER TO BE PRINTED
## SET ROW RANGE, WHICH DOES NOT CHANGE FOR EACH COLUMN. PIXEL WRITING WILL BE PERFORMED IN A COLUMN MAJOR ORDER
# LOWER LCD_CD TO SEND COMMAND
DISP: LUI X2, 917504
ORI X2, X2, 2 # LOAD X2 = E0000002 TO ADDRESS LCD_CD SIGNAL
SH X0, 0(X2)
# WRITE COMMAND WORD 2B TO CONFIGURE THE ROW (0-319)
LUI X2, 917504
ORI X2, X2, 12 # LOAD X2 = E000000C TO ADDRESS LCD DATA PORT
ADDI X13, X0, 43 # 2B, PREPARE COMMAND WORD: ILI9341_PAGEADDRSET 0X2B
SH X13, 0(X2)
# ISSUE AN LCD_WR LOW
LUI X2, 917504
ORI X2, X2, 4 # LOAD X2 = E0000004 TO ADDRESS LCD_WR SIGNAL
SH X0, 0(X2)
# ISSUE AN LCD_WR HIGH
SH X1, 0(X2)
# RAISE LCD_CD TO HIGH TO SEND DATA
LUI X2, 917504
ORI X2, X2, 2
SH X1, 0(X2)
# START ROW ADDRESS - HIGH BYTE
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X10, 0
SRLI X13, X13, 8
SH X13, 0(X2)
# WRITE A LOW TO HIGH TRANSITION TO LCD_WR
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# START ROW ADDRESS - LOW BYTE
LUI X2, 917504
ORI X2, X2, 12
SH X10, 0(X2) # WRITE LOW BYTE OF THE START ROW, X10[7:0] ARE EFFECTIVE SINCE THE DATA PORT OF THE LCD IS 8-BIT WIDE
# WRITE A LOW TO HIGH TRANSITION TO LCD_WR
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# END ROW ADDRESS - HIGH BYTE
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X10, 15
SRLI X13, X13, 8
SH X13, 0(X2)
# WRITE A LOW TO HIGH TRANSITION TO LCD_WR
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# END ROW ADDRESS - LOW BYTE
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X10, 15
SH X13, 0(X2) # WRITE LOW BYTE OF THE END ROW, X13[7:0] ARE EFFECTIVE SINCE THE DATA PORT OF THE LCD IS 8-BIT WIDE
# WRITE A LOW TO HIGH TRANSITION TO LCD_WR
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
## 12 COLUMNS TO WRITE
ADDI X14, X0, 12 #SET COLUMN LOOP VARIABLE (OUTER)
COLUMNLOOP: BEQ X14, X0, EXIT
NEXTCOLUMN: ADDI X14, X14, -1
# LOWER LCD_CD TO SEND COMMAND FIRST
LUI X2, 917504
ORI X2, X2, 2
SH X0, 0(X2)
# WRITE COMMAND 0X2A TO CONFIGURE COLUMN ADDRESS (0-239)
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X0, 42 # PREPARE COMMAND WORD: ILI9341_COLADDRSET 0X2A
SW X13, 0(X2)
# WRITE A LOW TO HIGH TRANSITION TO LCD_WR
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# RAISE LCD_CD TO SEND DATA NEXT
LUI X2, 917504
ORI X2, X2, 2
SH X1, 0(X2)
# START COLUMN ADDRESS - HIGH BYTE
LUI X2, 917504
ORI X2, X2, 12
ADD X13, X11, X14
SRLI X13, X13, 8
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# START COLUMN ADDRESS - LOW BYTE
LUI X2, 917504
ORI X2, X2, 12
ADD X13, X11, X14
SH X13, 0(X2) # X13[7:0] ARE EFFECTIVE
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# END COLUMN ADDRESS - HIGH BYTE
LUI X2, 917504
ORI X2, X2, 12
ADD X13, X11, X14
SRLI X13, X13, 8
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# END COLUMN ADDRESS - LOW BYTE
LUI X2, 917504
ORI X2, X2, 12
ADD X13, X11, X14
SH X13, 0(X2) # X13[7:0] ARE EFFECTIVE
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
## READ THE FONT RAM TO GET THE COLUMN WORD INTO X15
LUI X2, 917505
SLLI X13, X12, 5
ADD X2, X2, X13 
SLLI X13, X14, 1
ADD X2, X2, X13
LHU X15, 0(X2) # THE 16-BIT PIXEL WORD IN X15
## 16 PIXELS TO WRITE
LUI X2, 917504
ORI X2, X2, 2
SH X0, 0(X2) # LCD_CD = 0 FOR COMMAND
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X0, 44 # PREAPRE COMMAND 0X2C (FILL IN PIXEL DATA)
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4 # WRITE A LOW-TO-HIGH TRANSITION TO LCD_WR
SH X0, 0(X2)
SH X1, 0(X2)
LUI X2, 917504
ORI X2, X2, 2
SH X1, 0(X2) # LCD_CD = 1 FOR DATA
ADDI X16, X0, 16 # PIXEL COUNTER IN X16
SLLI X17, X1, 15 # PREPARE THE MASK REGISTER X17, INITIALLY SET TO ENABLE THE TESTING OF BIT15 OF THE READ PIXEL WORD
PIXELLOOP: BEQ X16, X0, COLUMNLOOP
AND X13, X15, X17 #USE MASK REGISTER TO MASK IRRELEVANT BITS
SRLI X17, X17, 1 #PREPARE TO MASK THE NEXT BIT
ADDI X16, X16, -1 #UPDATE PIXEL LOOP VARIABLE
BEQ X13, X0, WRITE0
# WRITE 1 WITH 16'd65535: A WHITE PIXEL (RGB565)
# COLOR HIGH BYTE
WRITE1: LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X0, 255
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# COLOR LOW BYTE
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X0, 255
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
JAL X13, PIXELLOOP
# WRITE 0 WITH 16'd31: BLUE PIXEL
# COLOR HIGH BYTE
WRITE0: LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X0, 0
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
# COLOR LOW BYTE
LUI X2, 917504
ORI X2, X2, 12
ADDI X13, X0, 31
SH X13, 0(X2)
LUI X2, 917504
ORI X2, X2, 4
SH X0, 0(X2)
SH X1, 0(X2)
JAL X13, PIXELLOOP 
EXIT: JALR X2, 0(X9) # EQUIVALENT TO JR $RA IN MIPS SINCE X9 CONTAINS RETURN ADDRESS AND OFFSET IS SET 0
#### DISP FUNCTION BODY ENDS HERE ####

############# DELAY10MS PROCEDURE ###########
## X29 OUTER LOOP COUNTING, X30 INNER LOOP COUNTING##
DELAY10MS: LUI X29, 0
ORI X29, X29, 100
INNER2A: LUI X30, 0
ORI X30, X30, 1250 
INNER1A: ADDI X30, X30, -1
BNE X30, X0, INNER1A
ADDI X29, X29, -1
BNE X29, X0, INNER2A
JALR X29, 0(X9) 
### DELAY10MS PROCEDURE ENDS HERE ###########

############# DELAY1S PROCEDURE ###########
## X29 OUTER LOOP COUNTING, X30 INNER LOOP COUNTING##
DELAY1S: LUI X31, 3535
SRLI X31, X31, 12
LUI X29, 0
OR X29, X29, X31
INNER2B: LUI X31, 3535
SRLI X31, X31, 12
LUI X30, 0
OR X30, X30, X31
INNER1B: ADDI X30, X30, -1
BNE X30, X0, INNER1B
ADDI X29, X29, -1
BNE X29, X0, INNER2B
JALR X29, 0(X9) 
### DELAY1S PROCEDURE ENDS HERE ###########


############# DELAY10S PROCEDURE ###########
## X29 OUTER LOOP COUNTING, X30 INNER LOOP COUNTING##
DELAY10S: LUI X31, 0
SRLI X31, X31, 12
LUI X29, 9
OR X29, X29, X31
INNER2C: LUI X31, 3535
SRLI X31, X31, 12
LUI X30, 0
OR X30, X30, X31
INNER1C: ADDI X30, X30, -1
BNE X30, X0, INNER1C
ADDI X29, X29, -1
BNE X29, X0, INNER2C
JALR X29, 0(X9) 
### DELAY1S PROCEDURE ENDS HERE ###########



